import validate from 'validate.js'; 
import moment from 'moment';

validate.extend(validate.validators.datetime, {
    // The value is guaranteed not to be null or undefined but otherwise it
    // could be anything.
    parse: function(value, options) {
        return +moment.utc(value);
    },
    // Input is a unix timestamp
    format: function(value, options) {
        var format = options.dateOnly ? "YYYY-MM-DD" : "YYYY-MM-DD hh:mm:ss";
        return moment.utc(value).format(format);
    }
});

// TODO: Move common methods to base model class
export default class BaseModel {

    constructor({ model = {}, token, api }) {
        this.errors = {};
        // for API
        this.token = token;
        // to check with dirty attributes if required
        this.originalAttributes = { ...model };
        // model data
        this.attributes = {};
        // safe attributes to send for update/create API
        this.safeAttributes = [];
        // attributes label for display, for active inputs
        // TODO: integrate with validate.js lib for error message
        this.labels = {};
        // check validate.js
        this.rules = {};
        this.api = api;
        this.originalFindData;
    }

    async find(id, data = {}) {
        if (this.api == null) {
            return false;
        }
        this.originalFindData = data;
        const response = await this.api.view(id, data, this.token);
        if (response.success) {
            this.attributes = { ...response.data };
            this.originalAttributes = { ...response.data };
            return this.attributes;
        } else {
            return false;
        }
    }

    async refresh() {
        if (this.api == null) {
            return false;
        }
        return await this.find(this.getId(), this.originalFindData);
    }

    async save() {
        if (this.api == null) {
            return false;
        }
        try {
            let response;
            if (this.isNewRecord()) {
                response = await this.api.create(this.getSafeAttributes(), this.token);
            } else {
                response = await this.api.update(this.getId(), this.getSafeAttributes(), this.token);
            }
            if (response.status == 422) {
                response.data.forEach((error) => {
                    this.errors[error.field] = error.message;
                });
                return false;
            }
            if (!response.success) {
                return false;
            }            
            this.originalAttributes = { ...response.data };
            this.attributes = { ...response.data };
            this.errors = {};
            return true;
        } catch (error) {
            return false;
        }
    }

    setError(attribute, message) {
        this.errors[attribute] = message;
    }

    set(attribute, value) {
        this.attributes[attribute] = value;
    }

    getError(attribute) {
        return this.errors[attribute];
    }

    get(attribute) {
        return this.attributes.hasOwnProperty(attribute) ? this.attributes[attribute] : null;
    }

    getId() {
        return this.attributes.id;
    }

    getLabel(attribute) {
        return this.labels[attribute];
    }

    getSafeAttributes() {
        return this.safeAttributes.reduce((obj, key) => {
            obj[key] = this.get(key);
            return obj;
        }, {});
    }

    reset() {
        this.attributes = { ...this.originalAttributes };
        this.errors = {};
    }

    isNewRecord() {
        return this.getId() == null;
    }

    hasErrors() {
        return Object.values(this.errors).some(value => value != null && value !== false);
    }

    validateField(attr) {
        let value = this.get(attr);
        if (value == '') {
            value = null; // because this stupid validate js dont allow empty
        }
        const error = validate({ [attr]: value }, { [attr]: this.rules[attr] }); 
        if (error) {
            this.setError(attr, error[attr][0]);
        } else {
            this.setError(attr, false);
        }
        return this.getError(attr);
    }

    prepareAttributesForError() {

    }

    validateForm() {
        let attributes = { ...this.attributes };
        Object.entries(attributes).forEach(([key, value]) => {
            if (value == '') {
                attributes[key] = null; // because this stupid validate js dont allow empty
            }
        });
        let errors = validate(attributes, this.rules);
        if (errors) {
            Object.entries(errors).forEach(([key, value]) => {
                this.setError(key, value[0]);
            });
            return false;
        } else {
            return true;
        }
    }

}